
import { Controller } from "./mvc/Controller.js";
let controller = new Controller();

controller.rangeSliderScript();


import "./RangeSlider.scss";



//Пропорция
//(x1_input - xMin_input) / d_MaxMin_input = x_slider / d_MaxMin_slider;


//функции расчета пропорциональных друг другу значений инпутов и X координат ползунков(в пикселях).
//x1_input = (d_MaxMin_input * x_slider) / d_MaxMin_slider + xMin_input;
//x1_slider = ((x_input - xMin_input) * d_MaxMin_slider) / d_MaxMin_input;
//x2_input = (d_MaxMin_input * x_slider) / d_MaxMin_slider + xMin_input;
//x2_slider = ((x_input - xMin_input) * d_MaxMin_slider) / d_MaxMin_input + slider_width;
//где: 
//  x_input - текущее значение инпута,
//  x_slider - текущая X координата ползунка относительно левой границы контейнера(левый марджин),
//  xMin_input/xMax_input - минимальные/максимальные значения инпутов,
//  xMin_slider/xMax_slider - минимальные/максимальные X координаты ползунков,
//  d_... - приращения соответствующих величин

//Вышеописанные формулы расчета устроены так что бы соответствовать следующим условиям:
// 1)Значение инпута соответсвующего 2му ползунку расчитывается относительно визуального положения левой границы 2го ползунка.
// 2)Значение инпута соответсвующего 1му ползунку расчитывается относительно визуального положения правой границы 1го ползунка.
//Это нужно чтобы при смыкании ближайших друг к другу границ ползунков их соответствующие значения инпутов были равны
//(т.е. при смыкании ползунков дельта инпут === 0). При этом если развести ползунки по крайним границам, то значения их
//соответствующих инпутов будут равны крайним значениям инпутов. 

//На деле чтобы достичь такого эффекта расчет пропорций ведется от левой границы 1го ползунка и 
//левой границы 2го ползунка минус ширина ползунка.